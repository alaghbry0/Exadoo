import logging
import json
import os
import asyncio
from aiogram import Router, types
from aiogram.types import Message, SuccessfulPayment, PreCheckoutQuery
from quart import current_app
from database.db_queries import record_payment

# ğŸ”¹ Ø¥Ù†Ø´Ø§Ø¡ Router Ø¬Ø¯ÙŠØ¯ Ù„Ù€ aiogram 3.x
router = Router()

# ğŸ”¹ Ø¥Ø¹Ø¯Ø§Ø¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# âœ… `RETRY_LIMIT` Ù„ØªØ­Ø¯ÙŠØ¯ Ø¹Ø¯Ø¯ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø·Ù„Ø¨ Ø¹Ù†Ø¯ ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„
RETRY_LIMIT = 3


# ğŸ”¹ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª Ù‚Ø¨Ù„ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø¯ÙØ¹
@router.pre_checkout_query()
async def handle_pre_checkout(pre_checkout_query: PreCheckoutQuery):
    try:
        payload = json.loads(pre_checkout_query.invoice_payload)

        if not payload.get("planId") or not payload.get("userId"):
            logging.error(f"âŒ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± ØµØ­ÙŠØ­Ø©: {payload}")
            await pre_checkout_query.answer(ok=False, error_message="Invalid payment payload")
            return

        # âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† total_amount Ù…Ø·Ø§Ø¨Ù‚ Ù„Ù„Ø³Ø¹Ø± Ø§Ù„Ù…ØªÙˆÙ‚Ø¹ (Ù„Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø£Ù…Ø§Ù†)
        expected_price = payload.get("amount", 0)
        if pre_checkout_query.total_amount != expected_price * 100:
            logging.warning(f"âš ï¸ Ù…Ø¨Ù„Øº ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚: Ù…ØªÙˆÙ‚Ø¹ {expected_price}, Ù„ÙƒÙ† ÙˆØµÙ„ {pre_checkout_query.total_amount / 100}")
            await pre_checkout_query.answer(ok=False, error_message="Price mismatch error")
            return

        logging.info(f"âœ… ÙØ§ØªÙˆØ±Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù…Ø³ØªØ®Ø¯Ù… {payload['userId']} Ø¨Ù‚ÙŠÙ…Ø© {pre_checkout_query.total_amount / 100}")
        await pre_checkout_query.answer(ok=True)

    except Exception as e:
        logging.error(f"âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙØ§ØªÙˆØ±Ø©: {e}")
        await pre_checkout_query.answer(ok=False, error_message="Internal error")


# ğŸ”¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ù†Ø§Ø¬Ø­
@router.message()
async def handle_successful_payment(message: Message):
    if isinstance(message.successful_payment, SuccessfulPayment):  # âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
        try:
            payment = message.successful_payment
            payload = json.loads(payment.invoice_payload)
            telegram_id = payload["userId"]
            plan_id = payload["planId"]
            payment_id = payment.telegram_payment_charge_id
            amount = payment.total_amount // 100  # ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Ø¬ÙˆÙ… Ø¥Ù„Ù‰ Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±

            logging.info(f"âœ… Ø§Ø³ØªÙ„Ø§Ù… Ø¯ÙØ¹Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† {telegram_id} Ù„Ù„Ø®Ø·Ø© {plan_id}, Ù…Ø¨Ù„Øº: {amount}")

            # âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØªØµØ§Ù„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            db_pool = getattr(current_app, "db_pool", None)
            if not db_pool:
                logging.error("âŒ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…ØªØ§Ø­Ø©!")
                return await message.answer("âš ï¸ Ø®Ø·Ø£ Ø¯Ø§Ø®Ù„ÙŠØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ù‹Ø§.")

            async with db_pool.acquire() as conn:
                # âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± Ù…Ø³Ø¬Ù„ Ù…Ø³Ø¨Ù‚Ù‹Ø§
                existing_payment = await conn.fetchrow("SELECT * FROM payments WHERE payment_id = $1", payment_id)
                if existing_payment:
                    logging.warning(f"âš ï¸ Ø§Ù„Ø¯ÙØ¹ Ù…Ø³Ø¬Ù„ Ù…Ø³Ø¨Ù‚Ù‹Ø§: {payment_id}")
                    return await message.answer("âœ… ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø¯ÙØ¹ØªÙƒ Ø¨Ø§Ù„ÙØ¹Ù„!")

                # âœ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯ÙØ¹ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
                await record_payment(conn, user_id=telegram_id, payment_id=payment_id, amount=amount, plan_id=plan_id)

            # âœ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø¥Ù„Ù‰ API Next.js Ù„ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
            success = await send_subscription_request(telegram_id, plan_id, payment_id)

            if success:
                return await message.answer("ğŸ‰ ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ø¨Ù†Ø¬Ø§Ø­!")
            else:
                return await message.answer("âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¯Ø¹Ù….")

        except Exception as e:
            logging.error(f"âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¯ÙØ¹: {e}")
            await message.answer("âš ï¸ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¯ÙØ¹ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ù‹Ø§.")


async def send_subscription_request(telegram_id, plan_id, payment_id):
    """
    ğŸ” Ø¯Ø§Ù„Ø© Ù„Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù…Ø¹ `Retry` ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„.
    âœ… ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… `current_app.aiohttp_session` Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ù„Ø³Ø© Ø¬Ø¯ÙŠØ¯Ø©.
    """
    subscribe_url = "https://exadoo.onrender.com/api/subscribe"
    webhook_secret = os.getenv("WEBHOOK_SECRET")

    session = getattr(current_app, "aiohttp_session", None)
    if not session or session.closed:
        logging.critical("âŒ Ø¬Ù„Ø³Ø© aiohttp ØºÙŠØ± ØµØ§Ù„Ø­Ø©!")
        return False

    payload = {
        "telegram_id": telegram_id,
        "subscription_type_id": plan_id,
        "payment_id": payment_id
    }
    headers = {"Authorization": f"Bearer {webhook_secret}"}

    for attempt in range(1, RETRY_LIMIT + 1):
        try:
            async with session.post(subscribe_url, json=payload, headers=headers) as resp:
                response_text = await resp.text()

                if resp.status == 200:
                    logging.info(f"âœ… ØªÙ… ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ù†Ø¬Ø§Ø­ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {telegram_id}")
                    return True
                else:
                    logging.error(f"âŒ ÙØ´Ù„ ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØŒ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© {attempt}/{RETRY_LIMIT}: {response_text}")

        except Exception as e:
            logging.error(f"âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ API Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØŒ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© {attempt}/{RETRY_LIMIT}: {e}")

        if attempt < RETRY_LIMIT:
            await asyncio.sleep(2 ** attempt)  # â³ Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ø¨Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©

    logging.critical(f"ğŸš¨ Ø¬Ù…ÙŠØ¹ Ù…Ø­Ø§ÙˆÙ„Ø§Øª ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {telegram_id} ÙØ´Ù„Øª!")
    return False
