import logging
import os
import asyncio
import sys
import json
import aiohttp  # âœ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ `aiohttp` Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª
from aiogram import Bot, Dispatcher, types
from aiogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo
from aiogram.exceptions import TelegramAPIError
from aiogram.filters import Command
from dotenv import load_dotenv
from quart import Blueprint  # âœ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ `Blueprint` Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ ÙÙŠ `app.py`

# ğŸ”¹ ØªØ­Ù…ÙŠÙ„ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©
load_dotenv()

# ğŸ”¹ Ø¥Ø¹Ø¯Ø§Ø¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# ğŸ”¹ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù‚ÙŠÙ… Ù…Ù† .env
CHANNEL_URL = os.getenv("CHANNEL_URL")
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
WEB_APP_URL = os.getenv("WEB_APP_URL")
SUBSCRIBE_URL = os.getenv("SUBSCRIBE_URL")  # âœ… ØªØ­Ù…ÙŠÙ„ Ø±Ø§Ø¨Ø· `/api/subscribe`
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET")  # âœ… ØªØ­Ù…ÙŠÙ„ `WEBHOOK_SECRET`

# âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙŠ Ø§Ù„Ø¨ÙŠØ¦Ø©
if not TELEGRAM_BOT_TOKEN or not WEB_APP_URL or not SUBSCRIBE_URL or not WEBHOOK_SECRET:
    raise ValueError("âŒ Ø®Ø·Ø£: ØªØ£ÙƒØ¯ Ù…Ù† Ø¶Ø¨Ø· Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦ÙŠØ©!")

# ğŸ”¹ Ø¥Ø¹Ø¯Ø§Ø¯ Aiogram 3.x
bot = Bot(token=TELEGRAM_BOT_TOKEN)
dp = Dispatcher()

# ğŸ”¹ Ø¥Ù†Ø´Ø§Ø¡ Blueprint Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ ÙÙŠ `app.py`
telegram_bot_bp = Blueprint("telegram_bot", __name__)  # âœ… ØªØºÙŠÙŠØ± Ø§Ù„Ø§Ø³Ù… Ø¥Ù„Ù‰ `telegram_bot_bp`


# ğŸ”¹ Ø¥Ø²Ø§Ù„Ø© Webhook ØªÙ…Ø§Ù…Ù‹Ø§ Ù‚Ø¨Ù„ ØªØ´ØºÙŠÙ„ Polling
async def remove_webhook():
    """ğŸ”„ Ø¥Ø²Ø§Ù„Ø© Webhook Ø­ØªÙ‰ ÙŠØ¹Ù…Ù„ Polling"""
    await bot.delete_webhook(drop_pending_updates=True)
    logging.info("âœ… ØªÙ… Ø¥Ø²Ø§Ù„Ø© Webhook Ø¨Ù†Ø¬Ø§Ø­!")


# ğŸ”¹ ÙˆØ¸ÙŠÙØ© /start
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, WebAppInfo
from aiogram import Bot, Dispatcher, types
import logging

@dp.message(Command("start"))
async def start_command(message: types.Message):
    """âœ… Ø¥Ø±Ø³Ø§Ù„ Ø²Ø± ÙØªØ­ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…ØµØºØ± Ø¹Ù†Ø¯ Ø§Ø³ØªØ®Ø¯Ø§Ù… /start (Ù…Ø¨Ø³Ø·)"""
    user_id = message.from_user.id
    full_name = message.from_user.full_name or "Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ø²ÙŠØ²"

    # âœ… Ù„ÙˆØ­Ø© Ù…ÙØ§ØªÙŠØ­ Ù…Ø¨Ø³Ø·Ø© Ø¨Ø²Ø± ÙˆØ§Ø­Ø¯ ÙÙ‚Ø· (ÙØªØ­ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…ØµØºØ±)
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="ğŸ”¹ ÙØªØ­ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚", web_app=WebAppInfo(url=WEB_APP_URL))],
        # âœ… ØªÙ… Ø­Ø°Ù Ø²Ø± "ÙØªØ­ Ø§Ù„Ù‚Ù†Ø§Ø©" Ù…Ø¤Ù‚ØªÙ‹Ø§ Ù„Ù„ØªØ¨Ø³ÙŠØ·
    ])

    logging.info(f"âœ… /start Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_id}, Full Name: {full_name}")

    welcome_text = (
        f"ğŸ‘‹ Ù…Ø±Ø­Ø¨Ù‹Ø§ {full_name}!\n\n"
        "Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ ÙÙŠ **@Exaado** \n"
        "Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¯Ø§Ø±Ø© Ø§Ø´ØªØ±Ø§ÙƒØ§ØªÙƒ ÙÙŠ Ù‚Ù†ÙˆØ§ØªÙ†Ø§ Ø¨Ø³Ù‡ÙˆÙ„Ø©.\n\n"
        "Ù†ØªÙ…Ù†Ù‰ Ù„Ùƒ ØªØ¬Ø±Ø¨Ø© Ø±Ø§Ø¦Ø¹Ø©! ğŸš€"
    )

    await message.answer(text=welcome_text, reply_markup=keyboard, parse_mode="Markdown")

    # âœ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù…Ø¹ Ø§Ù„Ø£Ø²Ø±Ø§Ø±
    await message.answer(text=welcome_text, reply_markup=keyboard, parse_mode="Markdown")


# ğŸ”¹ ÙˆØ¸ÙŠÙØ© Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹ Ø¥Ù„Ù‰ `/api/subscribe`
async def send_payment_to_subscribe_api(telegram_id: int, plan_id: int, payment_id: str, retries=3):
    """âœ… Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹ Ø¥Ù„Ù‰ `/api/subscribe` Ù…Ø¹ `Retry` ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„"""
    session = aiohttp.ClientSession()  # âœ… Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ù„Ø³Ø© `aiohttp`

    headers = {
        "Authorization": f"Bearer {WEBHOOK_SECRET}",
        "Content-Type": "application/json"
    }

    payload = {
        "telegram_id": telegram_id,
        "subscription_type_id": plan_id,
        "payment_id": payment_id
    }

    for attempt in range(1, retries + 1):
        try:
            logging.info(f"ğŸš€ Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¥Ù„Ù‰ {SUBSCRIBE_URL} (Ù…Ø­Ø§ÙˆÙ„Ø© {attempt}/{retries})...")

            async with session.post(SUBSCRIBE_URL, json=payload, headers=headers) as response:
                response_text = await response.text()

                if response.status == 200:
                    logging.info(f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ù†Ø¬Ø§Ø­ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… {telegram_id}.")
                    return True
                else:
                    logging.error(f"âŒ ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ! Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© {attempt}/{retries} - {response_text}")

        except Exception as e:
            logging.error(f"âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ (Ù…Ø­Ø§ÙˆÙ„Ø© {attempt}/{retries}): {e}")

        if attempt < retries:
            await asyncio.sleep(3)  # â³ Ø§Ù†ØªØ¸Ø§Ø± 3 Ø«ÙˆØ§Ù†Ù Ù‚Ø¨Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©

    logging.critical("ğŸš¨ Ø¬Ù…ÙŠØ¹ Ù…Ø­Ø§ÙˆÙ„Ø§Øª ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙØ´Ù„Øª!")
    return False


@dp.pre_checkout_query()
async def handle_pre_checkout(pre_checkout: types.PreCheckoutQuery):
    """âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ÙØ§ØªÙˆØ±Ø© Ù‚Ø¨Ù„ Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø¯ÙØ¹"""
    try:
        logging.info(f"ğŸ“¥ Ø§Ø³ØªÙ„Ø§Ù… pre_checkout_query Ù…Ù† {pre_checkout.from_user.id}: {pre_checkout}")

        # âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© invoice_payload
        payload = json.loads(pre_checkout.invoice_payload)
        if not payload.get("userId") or not payload.get("planId"):
            logging.error("âŒ `invoice_payload` ØºÙŠØ± ØµØ§Ù„Ø­!")
            await bot.answer_pre_checkout_query(pre_checkout.id, ok=False, error_message="Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± ØµØ§Ù„Ø­Ø©!")
            return

        # âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† ÙƒÙ„ Ø´ÙŠØ¡ ØµØ­ÙŠØ­ØŒ Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¯ÙØ¹
        await bot.answer_pre_checkout_query(pre_checkout.id, ok=True)
        logging.info(f"âœ… ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¯ÙØ¹ Ù„Ù€ {pre_checkout.from_user.id}")

    except Exception as e:
        logging.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ pre_checkout_query: {e}")
        await bot.answer_pre_checkout_query(pre_checkout.id, ok=False, error_message="Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹")


# ğŸ”¹ ÙˆØ¸ÙŠÙØ© Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ `successful_payment`
@dp.message()
async def handle_successful_payment(message: types.Message):
    """âœ… Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ `successful_payment` ÙˆÙ…Ø¹Ø§Ù„Ø¬ØªÙ‡"""
    payment = message.successful_payment
    if not payment:
        return

    try:
        logging.info(f"ğŸ“¥ Ø§Ø³ØªÙ„Ø§Ù… successful_payment Ù…Ù† {message.from_user.id}: {payment}")

        # âœ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        payload = json.loads(payment.invoice_payload)
        telegram_id = payload.get("userId")
        plan_id = payload.get("planId")
        payment_id = payment.telegram_payment_charge_id

        if not telegram_id or not plan_id or not payment_id:
            logging.error("âŒ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± ÙƒØ§Ù…Ù„Ø©!")
            return

        # âœ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ `/api/subscribe`
        await send_payment_to_subscribe_api(telegram_id, plan_id, payment_id)

    except Exception as e:
        logging.error(f"âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© successful_payment: {e}")


# ğŸ”¹ ØªØ´ØºÙŠÙ„ Polling Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Webhook
is_bot_running = False

async def start_bot():
    global is_bot_running
    if is_bot_running:
        logging.warning("âš ï¸ Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¨Ø§Ù„ÙØ¹Ù„! ØªØ¬Ø§Ù‡Ù„ ØªØ´ØºÙŠÙ„ Polling Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
        return

    is_bot_running = True
    await remove_webhook()
    logging.info("ğŸš€ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Polling Ù„Ù„Ø¨ÙˆØª...")
    try:
        await dp.start_polling(bot)
    except Exception as e:
        logging.error(f"âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ´ØºÙŠÙ„ Polling: {e}")
        sys.exit(1)  # Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø§Ù„ØªØ´ØºÙŠÙ„